// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LAYOUT_MONOCLE_H_
#define FLATBUFFERS_GENERATED_LAYOUT_MONOCLE_H_

#include "flatbuffers/flatbuffers.h"

namespace monocle {

struct LayoutView;
struct LayoutViewBuilder;

struct LayoutWindow;
struct LayoutWindowBuilder;

struct Layout;
struct LayoutBuilder;

struct LayoutView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayoutViewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12
  };
  uint64_t token() const {
    return GetField<uint64_t>(VT_TOKEN, 0);
  }
  uint32_t x() const {
    return GetField<uint32_t>(VT_X, 0);
  }
  uint32_t y() const {
    return GetField<uint32_t>(VT_Y, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TOKEN) &&
           VerifyField<uint32_t>(verifier, VT_X) &&
           VerifyField<uint32_t>(verifier, VT_Y) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           verifier.EndTable();
  }
};

struct LayoutViewBuilder {
  typedef LayoutView Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_token(uint64_t token) {
    fbb_.AddElement<uint64_t>(LayoutView::VT_TOKEN, token, 0);
  }
  void add_x(uint32_t x) {
    fbb_.AddElement<uint32_t>(LayoutView::VT_X, x, 0);
  }
  void add_y(uint32_t y) {
    fbb_.AddElement<uint32_t>(LayoutView::VT_Y, y, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(LayoutView::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(LayoutView::VT_HEIGHT, height, 0);
  }
  explicit LayoutViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayoutView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayoutView>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayoutView> CreateLayoutView(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t token = 0,
    uint32_t x = 0,
    uint32_t y = 0,
    uint32_t width = 0,
    uint32_t height = 0) {
  LayoutViewBuilder builder_(_fbb);
  builder_.add_token(token);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct LayoutWindow FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayoutWindowBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN = 4,
    VT_MAINWINDOW = 6,
    VT_MAXIMISED = 8,
    VT_SCREENX = 10,
    VT_SCREENY = 12,
    VT_SCREENWIDTH = 14,
    VT_SCREENHEIGHT = 16,
    VT_X = 18,
    VT_Y = 20,
    VT_WIDTH = 22,
    VT_HEIGHT = 24,
    VT_GRIDWIDTH = 26,
    VT_GRIDHEIGHT = 28,
    VT_MAPS = 30,
    VT_RECORDINGS = 32
  };
  uint64_t token() const {
    return GetField<uint64_t>(VT_TOKEN, 0);
  }
  bool mainwindow() const {
    return GetField<uint8_t>(VT_MAINWINDOW, 0) != 0;
  }
  bool maximised() const {
    return GetField<uint8_t>(VT_MAXIMISED, 0) != 0;
  }
  int32_t screenx() const {
    return GetField<int32_t>(VT_SCREENX, 0);
  }
  int32_t screeny() const {
    return GetField<int32_t>(VT_SCREENY, 0);
  }
  int32_t screenwidth() const {
    return GetField<int32_t>(VT_SCREENWIDTH, 0);
  }
  int32_t screenheight() const {
    return GetField<int32_t>(VT_SCREENHEIGHT, 0);
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  uint32_t gridwidth() const {
    return GetField<uint32_t>(VT_GRIDWIDTH, 0);
  }
  uint32_t gridheight() const {
    return GetField<uint32_t>(VT_GRIDHEIGHT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>> *maps() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>> *>(VT_MAPS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>> *recordings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>> *>(VT_RECORDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TOKEN) &&
           VerifyField<uint8_t>(verifier, VT_MAINWINDOW) &&
           VerifyField<uint8_t>(verifier, VT_MAXIMISED) &&
           VerifyField<int32_t>(verifier, VT_SCREENX) &&
           VerifyField<int32_t>(verifier, VT_SCREENY) &&
           VerifyField<int32_t>(verifier, VT_SCREENWIDTH) &&
           VerifyField<int32_t>(verifier, VT_SCREENHEIGHT) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_GRIDWIDTH) &&
           VerifyField<uint32_t>(verifier, VT_GRIDHEIGHT) &&
           VerifyOffset(verifier, VT_MAPS) &&
           verifier.VerifyVector(maps()) &&
           verifier.VerifyVectorOfTables(maps()) &&
           VerifyOffset(verifier, VT_RECORDINGS) &&
           verifier.VerifyVector(recordings()) &&
           verifier.VerifyVectorOfTables(recordings()) &&
           verifier.EndTable();
  }
};

struct LayoutWindowBuilder {
  typedef LayoutWindow Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_token(uint64_t token) {
    fbb_.AddElement<uint64_t>(LayoutWindow::VT_TOKEN, token, 0);
  }
  void add_mainwindow(bool mainwindow) {
    fbb_.AddElement<uint8_t>(LayoutWindow::VT_MAINWINDOW, static_cast<uint8_t>(mainwindow), 0);
  }
  void add_maximised(bool maximised) {
    fbb_.AddElement<uint8_t>(LayoutWindow::VT_MAXIMISED, static_cast<uint8_t>(maximised), 0);
  }
  void add_screenx(int32_t screenx) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_SCREENX, screenx, 0);
  }
  void add_screeny(int32_t screeny) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_SCREENY, screeny, 0);
  }
  void add_screenwidth(int32_t screenwidth) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_SCREENWIDTH, screenwidth, 0);
  }
  void add_screenheight(int32_t screenheight) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_SCREENHEIGHT, screenheight, 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_Y, y, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(LayoutWindow::VT_HEIGHT, height, 0);
  }
  void add_gridwidth(uint32_t gridwidth) {
    fbb_.AddElement<uint32_t>(LayoutWindow::VT_GRIDWIDTH, gridwidth, 0);
  }
  void add_gridheight(uint32_t gridheight) {
    fbb_.AddElement<uint32_t>(LayoutWindow::VT_GRIDHEIGHT, gridheight, 0);
  }
  void add_maps(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>>> maps) {
    fbb_.AddOffset(LayoutWindow::VT_MAPS, maps);
  }
  void add_recordings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>>> recordings) {
    fbb_.AddOffset(LayoutWindow::VT_RECORDINGS, recordings);
  }
  explicit LayoutWindowBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayoutWindow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayoutWindow>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayoutWindow> CreateLayoutWindow(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t token = 0,
    bool mainwindow = false,
    bool maximised = false,
    int32_t screenx = 0,
    int32_t screeny = 0,
    int32_t screenwidth = 0,
    int32_t screenheight = 0,
    int32_t x = 0,
    int32_t y = 0,
    int32_t width = 0,
    int32_t height = 0,
    uint32_t gridwidth = 0,
    uint32_t gridheight = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>>> maps = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutView>>> recordings = 0) {
  LayoutWindowBuilder builder_(_fbb);
  builder_.add_token(token);
  builder_.add_recordings(recordings);
  builder_.add_maps(maps);
  builder_.add_gridheight(gridheight);
  builder_.add_gridwidth(gridwidth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_screenheight(screenheight);
  builder_.add_screenwidth(screenwidth);
  builder_.add_screeny(screeny);
  builder_.add_screenx(screenx);
  builder_.add_maximised(maximised);
  builder_.add_mainwindow(mainwindow);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayoutWindow> CreateLayoutWindowDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t token = 0,
    bool mainwindow = false,
    bool maximised = false,
    int32_t screenx = 0,
    int32_t screeny = 0,
    int32_t screenwidth = 0,
    int32_t screenheight = 0,
    int32_t x = 0,
    int32_t y = 0,
    int32_t width = 0,
    int32_t height = 0,
    uint32_t gridwidth = 0,
    uint32_t gridheight = 0,
    const std::vector<flatbuffers::Offset<monocle::LayoutView>> *maps = nullptr,
    const std::vector<flatbuffers::Offset<monocle::LayoutView>> *recordings = nullptr) {
  auto maps__ = maps ? _fbb.CreateVector<flatbuffers::Offset<monocle::LayoutView>>(*maps) : 0;
  auto recordings__ = recordings ? _fbb.CreateVector<flatbuffers::Offset<monocle::LayoutView>>(*recordings) : 0;
  return monocle::CreateLayoutWindow(
      _fbb,
      token,
      mainwindow,
      maximised,
      screenx,
      screeny,
      screenwidth,
      screenheight,
      x,
      y,
      width,
      height,
      gridwidth,
      gridheight,
      maps__,
      recordings__);
}

struct Layout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN = 4,
    VT_NAME = 6,
    VT_WINDOWS = 8
  };
  uint64_t token() const {
    return GetField<uint64_t>(VT_TOKEN, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutWindow>> *windows() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutWindow>> *>(VT_WINDOWS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TOKEN) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_WINDOWS) &&
           verifier.VerifyVector(windows()) &&
           verifier.VerifyVectorOfTables(windows()) &&
           verifier.EndTable();
  }
};

struct LayoutBuilder {
  typedef Layout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_token(uint64_t token) {
    fbb_.AddElement<uint64_t>(Layout::VT_TOKEN, token, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Layout::VT_NAME, name);
  }
  void add_windows(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutWindow>>> windows) {
    fbb_.AddOffset(Layout::VT_WINDOWS, windows);
  }
  explicit LayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Layout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layout> CreateLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t token = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::LayoutWindow>>> windows = 0) {
  LayoutBuilder builder_(_fbb);
  builder_.add_token(token);
  builder_.add_windows(windows);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Layout> CreateLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t token = 0,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<monocle::LayoutWindow>> *windows = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto windows__ = windows ? _fbb.CreateVector<flatbuffers::Offset<monocle::LayoutWindow>>(*windows) : 0;
  return monocle::CreateLayout(
      _fbb,
      token,
      name__,
      windows__);
}

}  // namespace monocle

#endif  // FLATBUFFERS_GENERATED_LAYOUT_MONOCLE_H_
