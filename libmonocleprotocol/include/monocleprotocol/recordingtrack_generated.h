// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RECORDINGTRACK_MONOCLE_H_
#define FLATBUFFERS_GENERATED_RECORDINGTRACK_MONOCLE_H_

#include "flatbuffers/flatbuffers.h"

#include "codec_generated.h"
#include "codecindex_generated.h"
#include "index_generated.h"
#include "tracktype_generated.h"

namespace monocle {

struct RecordingTrack;
struct RecordingTrackBuilder;

struct RecordingTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordingTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TOKEN = 6,
    VT_TRACKTYPE = 8,
    VT_DESCRIPTION = 10,
    VT_FIXEDFILES = 12,
    VT_DIGITALSIGNING = 14,
    VT_ENCRYPT = 16,
    VT_FLUSHFREQUENCY = 18,
    VT_FILES = 20,
    VT_INDICES = 22,
    VT_CODECINDICES = 24,
    VT_TOTALTRACKDATATIME = 26,
    VT_TOTALTRACKDATA = 28
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *token() const {
    return GetPointer<const flatbuffers::String *>(VT_TOKEN);
  }
  monocle::TrackType tracktype() const {
    return static_cast<monocle::TrackType>(GetField<int8_t>(VT_TRACKTYPE, 0));
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool fixedfiles() const {
    return GetField<uint8_t>(VT_FIXEDFILES, 0) != 0;
  }
  bool digitalsigning() const {
    return GetField<uint8_t>(VT_DIGITALSIGNING, 0) != 0;
  }
  bool encrypt() const {
    return GetField<uint8_t>(VT_ENCRYPT, 0) != 0;
  }
  uint32_t flushfrequency() const {
    return GetField<uint32_t>(VT_FLUSHFREQUENCY, 0);
  }
  const flatbuffers::Vector<uint64_t> *files() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_FILES);
  }
  const flatbuffers::Vector<const monocle::INDEX *> *indices() const {
    return GetPointer<const flatbuffers::Vector<const monocle::INDEX *> *>(VT_INDICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<monocle::CodecIndex>> *codecindices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<monocle::CodecIndex>> *>(VT_CODECINDICES);
  }
  uint64_t totaltrackdatatime() const {
    return GetField<uint64_t>(VT_TOTALTRACKDATATIME, 0);
  }
  uint64_t totaltrackdata() const {
    return GetField<uint64_t>(VT_TOTALTRACKDATA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.VerifyString(token()) &&
           VerifyField<int8_t>(verifier, VT_TRACKTYPE) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyField<uint8_t>(verifier, VT_FIXEDFILES) &&
           VerifyField<uint8_t>(verifier, VT_DIGITALSIGNING) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPT) &&
           VerifyField<uint32_t>(verifier, VT_FLUSHFREQUENCY) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyOffset(verifier, VT_CODECINDICES) &&
           verifier.VerifyVector(codecindices()) &&
           verifier.VerifyVectorOfTables(codecindices()) &&
           VerifyField<uint64_t>(verifier, VT_TOTALTRACKDATATIME) &&
           VerifyField<uint64_t>(verifier, VT_TOTALTRACKDATA) &&
           verifier.EndTable();
  }
};

struct RecordingTrackBuilder {
  typedef RecordingTrack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(RecordingTrack::VT_ID, id, 0);
  }
  void add_token(flatbuffers::Offset<flatbuffers::String> token) {
    fbb_.AddOffset(RecordingTrack::VT_TOKEN, token);
  }
  void add_tracktype(monocle::TrackType tracktype) {
    fbb_.AddElement<int8_t>(RecordingTrack::VT_TRACKTYPE, static_cast<int8_t>(tracktype), 0);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(RecordingTrack::VT_DESCRIPTION, description);
  }
  void add_fixedfiles(bool fixedfiles) {
    fbb_.AddElement<uint8_t>(RecordingTrack::VT_FIXEDFILES, static_cast<uint8_t>(fixedfiles), 0);
  }
  void add_digitalsigning(bool digitalsigning) {
    fbb_.AddElement<uint8_t>(RecordingTrack::VT_DIGITALSIGNING, static_cast<uint8_t>(digitalsigning), 0);
  }
  void add_encrypt(bool encrypt) {
    fbb_.AddElement<uint8_t>(RecordingTrack::VT_ENCRYPT, static_cast<uint8_t>(encrypt), 0);
  }
  void add_flushfrequency(uint32_t flushfrequency) {
    fbb_.AddElement<uint32_t>(RecordingTrack::VT_FLUSHFREQUENCY, flushfrequency, 0);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> files) {
    fbb_.AddOffset(RecordingTrack::VT_FILES, files);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<const monocle::INDEX *>> indices) {
    fbb_.AddOffset(RecordingTrack::VT_INDICES, indices);
  }
  void add_codecindices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::CodecIndex>>> codecindices) {
    fbb_.AddOffset(RecordingTrack::VT_CODECINDICES, codecindices);
  }
  void add_totaltrackdatatime(uint64_t totaltrackdatatime) {
    fbb_.AddElement<uint64_t>(RecordingTrack::VT_TOTALTRACKDATATIME, totaltrackdatatime, 0);
  }
  void add_totaltrackdata(uint64_t totaltrackdata) {
    fbb_.AddElement<uint64_t>(RecordingTrack::VT_TOTALTRACKDATA, totaltrackdata, 0);
  }
  explicit RecordingTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordingTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordingTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordingTrack> CreateRecordingTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> token = 0,
    monocle::TrackType tracktype = monocle::TrackType::Video,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    bool fixedfiles = false,
    bool digitalsigning = false,
    bool encrypt = false,
    uint32_t flushfrequency = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<const monocle::INDEX *>> indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<monocle::CodecIndex>>> codecindices = 0,
    uint64_t totaltrackdatatime = 0,
    uint64_t totaltrackdata = 0) {
  RecordingTrackBuilder builder_(_fbb);
  builder_.add_totaltrackdata(totaltrackdata);
  builder_.add_totaltrackdatatime(totaltrackdatatime);
  builder_.add_codecindices(codecindices);
  builder_.add_indices(indices);
  builder_.add_files(files);
  builder_.add_flushfrequency(flushfrequency);
  builder_.add_description(description);
  builder_.add_token(token);
  builder_.add_id(id);
  builder_.add_encrypt(encrypt);
  builder_.add_digitalsigning(digitalsigning);
  builder_.add_fixedfiles(fixedfiles);
  builder_.add_tracktype(tracktype);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecordingTrack> CreateRecordingTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *token = nullptr,
    monocle::TrackType tracktype = monocle::TrackType::Video,
    const char *description = nullptr,
    bool fixedfiles = false,
    bool digitalsigning = false,
    bool encrypt = false,
    uint32_t flushfrequency = 0,
    const std::vector<uint64_t> *files = nullptr,
    const std::vector<monocle::INDEX> *indices = nullptr,
    const std::vector<flatbuffers::Offset<monocle::CodecIndex>> *codecindices = nullptr,
    uint64_t totaltrackdatatime = 0,
    uint64_t totaltrackdata = 0) {
  auto token__ = token ? _fbb.CreateString(token) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto files__ = files ? _fbb.CreateVector<uint64_t>(*files) : 0;
  auto indices__ = indices ? _fbb.CreateVectorOfStructs<monocle::INDEX>(*indices) : 0;
  auto codecindices__ = codecindices ? _fbb.CreateVector<flatbuffers::Offset<monocle::CodecIndex>>(*codecindices) : 0;
  return monocle::CreateRecordingTrack(
      _fbb,
      id,
      token__,
      tracktype,
      description__,
      fixedfiles,
      digitalsigning,
      encrypt,
      flushfrequency,
      files__,
      indices__,
      codecindices__,
      totaltrackdatatime,
      totaltrackdata);
}

}  // namespace monocle

#endif  // FLATBUFFERS_GENERATED_RECORDINGTRACK_MONOCLE_H_
